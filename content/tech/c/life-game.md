+++
aliases = ["/?p=28"]
Categories = ["c game","life game"]
Description = "用C写出的一个关于进化的小游戏"
Tags = ["c","进化","游戏"]
date = "2011-02-05T22:04:00+08:00"
ds_identifier = "1"
ds_title = "生命游戏"
title = "生命游戏"

+++
&nbsp;
<div>生命游戏是<a href="http://baike.baidu.com/view/3565.htm" target="_blank">英国</a>数学家约翰·何顿·康威在1970年发明的细胞自动机。它最初于1970年10月在《科学美国人》杂志中马丁·葛登能的“数学游戏”专栏出现。</div>
<div>生命游戏其实是一个零玩家游戏。它包括一个二维矩形世界，这个世界中的每个方格居住着一个活着的或死了的细胞。一个细胞在下一个时刻生死取决于相邻八个方格中活着的或死了的细胞的数量。如果相邻方格活着的细胞数量过多，这个细胞会因为资源匮乏而在下一个时刻死去；相反，如果周围活细胞过少，这个细胞会因太孤单而死去。实际中，你可以设定周围活细胞的数目怎样时才适宜该细胞的生存。如果这个数目设定过高，世界中的大部分细胞会因为找不到太多的活的邻居而死去，直到整个世界都没有生命；如果这个数目设定过低，世界中又会被生命充满而没有什么变化。实际中，这个数目一般选取2或者3；这样整个生命世界才不至于太过荒凉或拥挤，而是一种动态的平衡。这样的话，游戏的规则就是：当一个方格周围有2或3个活细胞时，方格中的活细胞在下一个时刻继续存活；即使这个时刻方格中没有活细胞，在下一个时刻也会“诞生”活细胞。在这个游戏中，还可以设定一些更加复杂的规则，例如当前方格的状况不仅由父一代决定，而且还考虑祖父一代的情况。你还可以作为这个世界的God，随意设定某个方格细胞的死活，以观察对世界的影响。 　　在游戏的进行中，杂乱无序的细胞会逐渐演化出各种精致、有形的结构；这些结构往往有很好的对称性，而且每一代都在变化形状。一些形状已经锁定，不会逐代变化。有时，一些已经成形的结构会因为一些无序细胞的“入侵”而被破坏。但是形状和秩序经常能从杂乱中产生出来。 　　这个游戏被许多计算机程序实现了。Unix世界中的许多Hacker喜欢玩这个游戏，他们用字符代表一个细胞，在一个计算机屏幕上进行演化。著名的<a href="http://baike.baidu.com/view/36272.htm" target="_blank">GNU</a> <a href="http://baike.baidu.com/view/113220.htm" target="_blank">Emacs</a>编辑器中就包括这样一个小游戏。</div>
<h1><strong>原理 </strong></h1>
<div>细胞自动机（又称元胞自动机），名字虽然很深奥，但是它的行为却是非常美妙的。所有这些怎样实现的呢？我们可以把计算机中的宇宙想象成是一堆方格子构成的封闭空间，尺寸为N的空间就有N*N个格子。而每一个格子都可以看成是一个生命体，每个生命都有<strong>生</strong>和<strong>死</strong>两种状态，如果该格子生就显示兰色，死则显示白色。每一个格子旁边都有邻居格子存在，如果我们把3*3的9个格子构成的正方形看成一个基本单位的话，那么这个正方形中心的格子的邻居就是它旁边的8个格子。 　　每个格子的生死遵循下面的原则： 　　1． 如果一个细胞周围有3个细胞为生（一个细胞周围共有8个细胞），则该细胞为生（即该细胞若原先为死，则转为生，若原先为生，则保持不变） 。 　　2． 如果一个细胞周围有2个细胞为生，则该细胞的生死状态保持不变； 　　3． 在其它情况下，该细胞为死（即该细胞若原先为生，则转为死，若原先为死，则保持不变设定图像中每个像素的初始状态后依据上述的游戏规则演绎生命的变化，由于初始状态和迭代次数不同，将会得到令人叹服的优美图案）。 　　这样就把这些若干个格子（生命体）构成了一个复杂的动态世界。运用简单的3条作用规则构成的群体会涌现出很多意想不到的复杂性为，这就是复杂性科学的研究焦点。 　　细胞自动机有一个通用的形式化的模型，每个格子（或细胞）的状态可以在一个有限的状态集合S中取值，格子的邻居范围是一个半径r，也就是以这个格子为中心，在距离它r远的所有格子构成了这个格子的邻居集合，还要有一套演化规则，可以看成是一个与该格子当前状态以及邻居状态相关的一个函数，可以写成f:S*S^((2r)^N-1)-&gt;S。这就是细胞自动机的一般数学模型。 　　最早研究细胞自动机的科学家是冯·诺伊曼，后来康韦发明了上面展示的这个最有趣的细胞自动机程序：《生命游戏》，而wolfram则详尽的讨论了一维世界中的细胞自动机的所有情况，认为可以就演化规则f进行自动机的分类，而只有当f满足一定条件的时候，系统演化出来的情况才是有活力的，否则不是因为演化规则太死板而导致生命的死亡，就是因为演化规则太复杂而使得随机性无法克服，系统乱成一锅粥，没有秩序。后来人工生命之父克里斯·朗顿进一步发展了元胞自动机理论。并认为具有8个有限状态集合的自动机就能够涌现出生命体的自复制功能。他根据不同系统的演化函数f，找到了一个参数lamda用以描述f的复杂性，得出了结论只有当lamda比混沌状态的lamda相差很小的时候，复杂的生命活系统才会诞生，因此，<a href="http://baike.baidu.com/view/1785942.htm" target="_blank">朗顿</a>称生命诞生于“混沌的边缘”！并从此开辟了“人工生命”这一新兴的交叉学科！ 　　如今细胞自动机已经在地理学、经济学、计算机科学等领域得到了非常广泛的应用！</div>
<div>抄了个代码，挺好玩的。</div>
<div>
```C
#include<stdio.h>
#include<stdlib.h>
#define HS 20
#define LS 60
#define SHI 1
#define FOU 0
#define XB '\01'
#define KB ' '
#define HOU1 2
#define HOU2 3
int sf_jx(void);
int js_ljsm(const int gzh,const int gzl,char sj[][LS],const int sjhs);
void cb_shijie(char from[][LS],char to[][LS],const int hs);
void js_weilai(char sj[][LS],const int hs);
void xs_shijie(char sj[][LS],const int hs);
void du_cssj(char sj[][LS],const int hs);

int main(void)
{
    char shijie[HS][LS];
    du_cssj(shijie,sizeof(shijie)/sizeof(shijie[0]));
    do
    {
    xs_shijie(shijie,sizeof(shijie)/sizeof(shijie[0]));
    js_weilai(shijie,sizeof(shijie)/sizeof(shijie[0]));
    }
    while(sf_jx());
    system("pause");
    return 0;
}
int js_ljsm(const int gzh,const int gzl,char sj[][LS],const int sjhs)
{
    int sm=0;
    int h,l;
    for(h=gzh-1;h&lt;=gzh+1;h++)
    {
       for(l=gzl-1;l&lt;=gzl+1;l++)
       {
         if(h&lt;0||h&gt;=sjhs)
            continue;
         if(l&lt;0||l&gt;sizeof(sj[0])/sizeof(sj[0][0]))
            continue;
         if(sj[h][l]==XB)
            sm++;
       }
    }
    return sm;
}
void cb_shijie(char from[][LS],char to[][LS],const int hs)
{
     int h,l;
     for(h=0;h&lt;hs;h++)
        for(l=0;l&lt;sizeof(from[0])/sizeof(from[0][0]);l++)
           to[h][l]=from[h][l];
     return ;
}
void js_weilai(char sj[][LS],const int hs)
{
     char dpsj[HS][LS];
     cb_shijie(sj,dpsj,hs);
     {
        int h,l;
        for(h=0;h&lt;hs;h++)
        {for(l=0;l&lt;sizeof(sj[0])/sizeof(sj[0][0]);l++)
          {
            int ljsm;
            ljsm=js_ljsm(h,l,dpsj,sizeof(dpsj)/sizeof(dpsj[0]));
            switch (ljsm)
               {case HOU1:break;
                case HOU2:sj[h][l]=XB;break;
                default:sj[h][l]=KB;break;
               }

          }
        }
     }
     return ;
}
void xs_shijie(char sj[][LS],const int hs)
{
     int h,l;
     system("CLS");
     for(h=0;h&lt;hs;h++)
       {for(l=0;l&lt;sizeof(sj[0])/sizeof(sj[0][0]);l++)
          {
          putchar(sj[h][l]);                                          
          }
          putchar('\n');
       }
       putchar('\n');
       putchar('\n');
       return ;
}
void du_cssj(char sj[][LS],const int hs)
{
     int h,l;
     freopen("input.txt","r",stdin);
     for(h=0;h&lt;hs;h++)
       {for(l=0;l&lt;sizeof(sj[0])/sizeof(sj[0][0]);l++)
        {
         char c;
         scanf("%c",&amp;c);
         #define SBBZ '*'
         sj[h][l]=(c==SBBZ)?XB:KB;
         #undef SBBZ
        }
       getchar();
      }
      freopen("CON","r",stdin);
      return;
}
int sf_jx(void)
{
    printf("continue?");
    return (getchar()=='\n')?1:0;
}
```

输入文件 input.txt(大家可以自己写，*代表细胞位置)

1**4567890123456789012345*78**123456789012345*78**1234567890
12345*78**123456789012345*78**123456789012345*78**1234567890
12*4567890123456789012345*78**123456789012345*78**1234567890
12*4567890123456789012345*78**123456789012345*78**1234567890
12*4567890123456789012345*78**123456789012345*78**1234567890
12*45678901234567890*2345*78**123456789012345*78**1234567890
12*4567890123456789012345*78**123456789012345*78**1234567890
12*4567890123456789012345*78**123456789012345*78**1234567890
12*4567890123456789012345*78**123456*89012345*78**1234567890
12*45678901234567890*2345*78**123456789012345*78**1234567890
12*4567890123456789012345*78**123456789012345*78**1234567890
12*4567890123456789012345*78**123456789012345*78**1234567890
12*4567890123456789012345*78**123456789012345*78**1234567890
12*4567890123456789012345*78**123456789012345*78**1234567890
12*4567890123456789012345*78**123456789012345*78**1234567890
12*4567890123456789012345*78**123456789012345*78**1234567890
12*4567890123456789012345*78**123456789012345*78**1234567890
12*4567890123456789012345*78**123456789012345*78**1234567890
12*4567890123456789012345*78**123456789012345*78**1234567890
12*4567890123456789012345*78**123456789012345*78**1234567890

</div>
